% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clique_cluste.R
\name{relax_cliques_optimally}
\alias{relax_cliques_optimally}
\title{Optimal clique relaxation by clique supergraph weight threshold optimization}
\usage{
relax_cliques_optimally(
  partition,
  S,
  t_S,
  CS = NULL,
  relax_method = "greedyCliqueJoin",
  clq_importance = NULL,
  cs_thr_objective = "modularity",
  n_init_steps = 10,
  keep_init_eval_history = TRUE,
  keep_init_partitions = FALSE,
  precis = TRUE,
  tol = 0.1,
  do_signif = TRUE,
  lvl = 0.05,
  ...
)
}
\arguments{
\item{partition}{A clique membership indicator vector (of nodes), 0 denotes free nodes.}

\item{S}{An original, non thresholded node similarity matrix}

\item{t_S}{A threshold that was used on \code{S} to find \code{partition}}

\item{CS}{A clique to clique similarity matrix (assumed to be computed by \code{\link[=cliqueSimilarity]{cliqueSimilarity()}}}

\item{relax_method, clq_importance}{Clique relaxation specification, see \code{\link[=relax_cliques]{relax_cliques()}}}

\item{cs_thr_objective}{A character string specifying objective function to optimize when searching for threshold or an objective function, see details.}

\item{n_init_steps, keep_init_eval_history, keep_init_partitions, precis, tol, Arguments}{specifying threshold searching, see details and \code{\link[=thr_optimizer]{thr_optimizer()}} for in depth explaination.}
}
\value{
A list with following named components:
\itemize{
\item \code{frac} - final chosen threshold of weights of \code{CS}
\item \code{objective} - A value of \code{cs_thr_objective} corresponding to partition obtained using \code{frac}
\item \code{membership} - a sublist of 2:
\itemize{
\item \code{cliq} - a clique membership cluster indicator vector of final partition (cliques are in the same cluster if relaxation joined them together)
\item \code{node} - a node membership cluster indicator vector of final (node is in a cluster \code{i} if clique to which it belongs is inside cluster \code{i})
}
\item \code{init_search_points}, \code{init_scores} Vectors of length \code{n_init_steps} containing search points and corresponding scores computed in initial search (set if \code{keep_init_eval_history} is \code{TRUE} and \code{n_init_steps} is not \code{NULL})
\item \code{init_partitions} A list of length \code{n_init_steps} containing clique partitions corresponding to scores and search points mentioned above (set if \code{keep_init_partitions} is \code{TRUE} and \code{n_init_steps} is not \code{NULL}). Note that here each partition is a two el. list structured like \code{membership} element described above.
}

Additionally, attribute \code{core} is set to element \code{membership} if \code{relax_method=="greedyCliqueJoin"}, a list with two elements:
\itemize{
\item \code{cliq} - logical vector, entry is \code{TRUE} if given clique is a \code{core}
\item \code{node} - logical vector, entry is \code{TRUE} if given node belongs to \code{core} clique
}
(see details of \code{\link[=relax_cliques]{relax_cliques()}} for meaning of \code{core})

Attribute \code{labelMap} is set if non zero labels of cliques were not consecutive integers, see details.
}
\description{
Given a graph partitioned into cliques this function will join them into clusters by optimizing clique similarity threshold below which clique
similarities will be ignored.
}
\details{
Function will consider a clique similarity supergraph with weight matrix \code{CS} where
\verb{CS_\{ij\} = [n observed edges between cliques i,j]/[n total possible edges between cliques i,j]},
clusters (of original nodes) resulting from clique relaxation will maximize given \code{cs_thr_objective} objective function.

Clique relaxation methods are specified by argument \code{relax_method}, see \code{\link[=relax_cliques]{relax_cliques()}} for description of each available method.
This function basically performs \code{\link[=relax_cliques]{relax_cliques()}} step for different values of \code{frac} until it find a maximum of \code{cs_thr_objective} function.

Optimization is done by searching ranges of weights in \code{CS} in the same manner as it is done in \code{\link[=thr_optimizer]{thr_optimizer()}} (but in that function, search and thresholding is done on original node simil. matrix \code{S}).
However, here, objective function is evaluated based on original similarity matrix \code{S}, not \code{CS}.
So the search is performed in two steps like in \code{\link[=thr_optimizer]{thr_optimizer()}} and arguments:
\code{n_init_steps}, \code{keep_init_eval_history}, \code{keep_init_partitions}, \code{precis}, \code{tol}
are acting exactly the same as in \code{\link[=thr_optimizer]{thr_optimizer()}}, but range of weights which is searched is that of \code{CS} matrix and scores are obtained by
evaluating \code{cs_thr_objective} on resulting partition and original node similarity \code{S}.

\code{cs_thr_objective} can be a character string, then it can either be \code{modularity} (optimizing \code{\link[igraph:modularity.igraph]{igraph::modularity()}}) or \code{mst} (optimizing \code{\link[=MinST_DunnIndex]{MinST_DunnIndex()}}, converting similarities to distances).
This argument can also be a function. Valid function here must accept node cluster membership vector as first argument and original node to node similarity matrix \code{S} as the second. Additional arguments can be passed by \code{...}. Return value should be scalar (the bigger the better grade).

\code{relax_method}, \code{clq_importance} are passed to \code{\link[=relax_cliques]{relax_cliques()}}, see that function for description of these arguments.

If \code{CS} is \code{NULL}, then group similarity matrix of \code{partition} is constructed by \code{\link[=cliqueSimilarity]{cliqueSimilarity()}}.
This includes relabeling non zero clique labels to consecutive integers from 1 to number of cliques.
Note that \code{cliqueSimilarity} does not take into the account the weights so \code{SorCS} can be adjacency matrix for the same effect.

Result of relabeling is stored in the attribute \code{labelMap} (if it was needed) inherited from output of \code{cliqueSimilarity}.
If \code{CS} is not \code{NULL}, then it is assumed to be precomputed output of \code{\link[=cliqueSimilarity]{cliqueSimilarity()}} and \code{labelMap} is inherited from it.
}
\examples{
library(magrittr)
data(leukemia)
#example of not so good similarity threshold 
#optimal clique relaxation tries to get most of it anyway
opt_= list( thr=critical_mst_thr(leukemia) )
opt_$maximizer_partition=greedyCliquePartitioner(leukemia \%tht\% opt_$thr)
relax_cliques_optimally(opt_$maximizer_partition \%>\% uniqueSingletonLabels(), leukemia, opt_$thr,
                        n_init_steps=2)-> relax_result #toy example,init steps to 2 to make prec. search useful
data(leukemia_clusters) #to compare with discovered clusters
igraph::compare(leukemia_clusters, relax_result$membership$node, "adjusted.rand")
#plot the initial search history
plot(relax_result$init_search_points, relax_result$init_scores, xlab="thresholds checked in initial search",
ylab="objective function value", type="p", pch=16)
# mark the result of precision search also
abline(v=relax_result$frac)
abline(h=relax_result$objective)
}
