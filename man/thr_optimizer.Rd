% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/thr_seeke.R
\name{thr_optimizer}
\alias{thr_optimizer}
\title{Find optimal threshold of weights of a graph based on partition scoring}
\usage{
thr_optimizer(
  S,
  expansion_mode = "basic",
  cl_score = "complexity",
  n_init_steps = 10,
  keep_init_eval_history = TRUE,
  keep_init_partitions = FALSE,
  precis = TRUE,
  tol = 0.1,
  keep_final_partition = TRUE,
  custom_partitioner = NULL,
  custom_partitioner_otherArgs = NULL,
  ...
)
}
\arguments{
\item{S}{A square matrix of weights of a undirected similarity graph. Assumed to be symmetric.}

\item{expansion_mode}{Passed to \code{cliquePartiotioneR::greedyCliquePartitioneR()}, a strategy for clique building.}

\item{cl_score}{A character string indicating a type of clique parition scoring to maximize OR a custom clique scoring function. See details for requirements for such a function.}

\item{n_init_steps}{If not \code{NULL}, number of initial steps of exhaustive search on uniformly spaced points on range of weights of \code{S} to compute.}

\item{keep_init_eval_history}{If \code{TRUE}, the search points and values of \code{cl_score} evaluated at those points are returned (applicable if \code{n_init_steps} is not \code{NULL})}

\item{keep_init_partitions}{If \code{TRUE}, list of partitions of length \code{n_init_steps} is returned. Each element corresponds to partition computed at each initial search point (applicable if \code{n_init_steps} is not \code{NULL}).}

\item{precis}{If \code{TRUE}, then the function will perform precise search for a maximum of \code{cl_score} based on \code{stats::optimize()} function (possibly after initial exhaustive search if \code{n_init_steps} is not \code{NULL}).}

\item{tol}{Passed to \code{stats::optimize}, only matters if \code{precis} is \code{TRUE}. The smaller the value, the longer the precise search will take.}

\item{keep_final_partition}{If \code{TRUE}, the final partition maximizing the \code{cl_score} is returned along with the final score and threshold found.}

\item{custom_partitioner}{A custom node grouping function used instead of clique partitioning, see details.}

\item{custom_partitioner_otherArgs}{List of other named arguments passed to \code{custom_partitioner} if is used.}

\item{...}{Additional arguments passed to partition scoring function (\code{cl_score} if it is a function).}
}
\value{
A list with the following fields:
\itemize{
\item \code{thr} Threshold of weights in \code{S} that maximizes \code{cl_score} on a thresholded \code{S}
\item \code{objective} A value of \code{cl_score} corresponding to partition obtained using \code{thr}.
\item  \code{maximizer_partition} A partition which resulted at \code{cl_score} value in \code{objective}(set if \code{keep_final_partition} is \code{TRUE})
\item \code{init_search_points}, \code{init_scores} Vectors of length \code{n_init_steps} containing search points and corresponding scores computed in initial search (set if \code{keep_init_eval_history} is \code{TRUE} and \code{n_init_steps} is not \code{NULL})
\item \code{init_partitions} A list of length \code{n_init_steps} containing clique partitions corresponding to scores and search points mentioned above (set if \code{keep_init_partitions} is \code{TRUE} and \code{n_init_steps} is not \code{NULL})
}
}
\description{
Given a predefined scoring strategy of a partition of a set of nodes into groups, function will pick
such a threshold of weights \code{thr} such that for a thresholded graph
(with connections with weight \verb{< thr} zeroed out) the value of the score is maximized.
By default, the partitioning is done by splitting a graph into cliques using
\code{\link[cliquePartitioneR:greedyCliquePartitioner]{cliquePartitioneR::greedyCliquePartitioner()}}.
However, by supplying partitioning function by \code{custom_partitioner} argument,
another strategy can be used, see details.
}
\details{
The search for the optimal threshold \code{thr} is performed in two stages.
Either of them can be run on its own based on input arguments.

If \code{n_init_steps} is not \code{NULL}, then the range of weights in \code{S} (excluding diagonal) gets sampled at
\code{n_init_steps} uniformly spaced points and \code{cl_score} gets computed at each of those points.

If \code{precis} is \code{TRUE}, then the precise search is performed.
If \code{n_init_steps} was not \code{NULL}, the precise search is done on interval containing maximum from first
exhaustive search:
\itemize{
\item If maximum was found on any of the points in the interior of the range, say at step \code{i}, then precise search is performed on an interval between points \code{i-1} and \code{i+1}
\item On the other hamd, if maximum was found on the first (or last) point of the range,
then the precise search is done between points \code{1} and \code{2} (or between \code{n_init_steps-1} and \code{n_init_steps} in the second case).
}
If \code{n_init_steps} was \code{NULL}, then precise search will be done on the whole range of weights of \code{S}.

Precise search works by a combination of golden section search and parabolic interpolation
(see \code{\link[stats:optimize]{stats::optimize()}}. A function computing \code{cl_score} is assumed to be continuous and this is implemented
by linearly interpolating its values between values of weights actually present in \code{S}.

If \code{cl_score} is character it can be set to any of strings in \code{c('n_cliques', 'complexity')}:
\itemize{
\item 'n_cliques' : the value of the score of a clique parition is number of cliques of size at least 3.
\item 'complexity' :the score of the partition is defined as \code{log} of the factorial
describing clique sizes and their number: \verb{K! * size_1! * size_2! ... size_K!} where
\code{K} is the total number of cliques in the partition (including singletons and pairs)
and \code{size_i} gives size of clique number \code{i}.
}
If \code{cl_score} is a function, then none of the above scores are used and the supplied custom function
is used instead. A valid \code{cl_score} function should accept vector of membership labels of nodes to each clique
as first argument
(where 0 labels encodes free nodes outside of true cliques) and return a scalar value (the higher the better
the input clique partition is evaluated).
Other arguments for \code{cl_score} are passed by \code{...} (constant per each call in the optimization process).

If \code{custom_partitioner} is not \code{NULL} it is assumed that it is a function.
It will be used for splitting nodes into groups instead of clique based method and resulting partitions
will be scored by \code{cl_score}. Valid function for \code{custom_partitioner} should accept similarity matrix
as its first argument.
Additional (constant throughout the optimization) arguments passed to \code{custom_partitioner} should be
supplied by \code{custom_partitioner_otherArgs} named list.
}
\examples{
data(leukemia)
opt_res<-thr_optimizer(leukemia) 
print(opt_res$thr)
plot(opt_res$init_search_points, opt_res$init_scores)
abline(v= opt_res$thr)
abline(h= opt_res$objective)
table(opt_res$maximizer_partition)
heatmap(leukemia, scale="none", Rowv=NA, Colv=NA, main="original similarity matrix")
heatmap(leukemia \%thr\% opt_res$thr, scale="none", Rowv=NA, Colv=NA, main="thresholed similarity")
}
\seealso{
\code{\link[=critical_mst_thr]{critical_mst_thr()}}, \code{\link[=\%thr\%]{\%thr\%()}}
}
